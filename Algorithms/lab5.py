# -*- coding: utf-8 -*-
"""
Лабораторна робота №5 з курсу "Теорія алгоритмів"
Спеціальність: Інформаційні управляючі системи та технології

МЕТА: 
    Вивчення та дослідження роботи пірамід.
    
ОПИС РОБОТИ:
    В даній роботі необхідно розв'язати наступну задачу визначення послідовності
    медіан для заданого вхідного масиву. Нагадаємо, що медіаною для масиву
    називається елемент, який займає середнє положення у відсортованому масиві.
    Так, якщо кількість елементів у масиві непарна, то медіана одна та індекс
    її у відсортованому масиві визначається як [n/2] (де n - розмір вхідного
    масиву). Якщо кількість елементів у масиві парна, то медіан буде дві та їх
    індекси визначаються за формулами [n/2] та [n/2] + 1.
    
    Задача формулюється наступним чином. Нехай заданий вхідний масив
    A = [x_1, ..., x_N]. Припустимо, що елементи масиву поступають на вхід 
    програми послідовно: в кожний момент часу розглядається новий елемент x_i.
    Необхідно для кожного i (від 1 до N) визначити медіану підмасиву 
    A' = [x_1, ..., x_i], тобто медіану для масиву елементів, які були 
    отримані програмою на даний момент часу. Причому вимагається, щоб кожна 
    медіана визначалась за час O(log(i)).
    
    Цю задачу можна розв'язати, використовуючи дві піраміди (heap) наступним 
    чином. 
    - Позначимо через H_low незростаючу піраміду (max-heap), яка буде 
        містити елементи меншої половини масиву (тобто такі елементи, які у 
        відсортованому поточному елементі A' будуть розташовуватись у першій,
        меншій половині масиву). 
    - Позначимо через H_high неспадну піраміду (min-heap), яка буде містити 
        елементи більшої половини масиву (тобто такі елементи, які у 
        відсортованому поточному елементі A' будуть розташовуватись у другій,
        більшій половині масиву).
        
    Тепер розглянемо роботу процедури, яка розв'язує поставлену задачу із 
    використанням двох наведених пірамід. Нехай додається черговий
    елемент x_i. На поточний момент сумарна кількість елементів, які 
    зберігаються в обох пірамідах, становить (i-1). Наступні кроки, які ми 
    повинні виконати:
        
        1) Визначимо в яку піраміду (H_low або H_high) потрібно додати новий 
        елемент. Якщо x_i менше ніж найбільший елемент з H_low (тобто новий 
        елемент буде розташовуватись в меншій поточній половині), то додаємо
        його у цю піраміду. В іншому випадку додаємо елемент в піраміду H_high.
        
        2) В кожний момент часу, тобто на кожній ітерації роботи алгоритму, повинен 
        зберігатись наступний інваріант: кількість елементів в піраміді H_low не 
        повинна відрізнятись від кількості елементів в H_high не більше ніж на 
        одиницю. Під час виконання попереднього етапу цей варіант може
        порушитись. Тому тепер необхідно відновити даний інваріант: якщо 
        у піраміді H_low елементів більше на 2 за H_high, то визначаємо 
        найбільший елемент з H_low і вставляємо його у H_high; якщо кількість 
        елементів у H_high більше на 2 за H_low, то визначаємо найменший 
        елемент з H_high і вставляємо його у H_low. Зрозуміло, що після 
        кожної вставки нового елементу в піраміду необхідно перевіряти
        властивість піраміди: для H_low - властивість незростаючої піраміди,
        для H_high - властивість неспадної піраміди.
        
        3) Визначити медіану для поточного масиву A' = [x_1, ..., x_i]:
            - Якщо кількість елементів у A' парна, то після збереження інваріанту
            у пункті 2, кількість елементів у пірамідах H_low та H_high буде
            рівною. Тому одна медіана буде найбільшим елементом H_low, а 
            інша медіана - найменшим елементом H_high.
            - Якщо кількість елементів у A' непарна, то єдина медіана буде
            знаходитись у тій піраміді, в якій кількість елементів буде більше 
            (на одиницю) за кількість в іншій. Тому, якщо кількість елементів у 
            H_low більше за H_high, то медіана - це найбільший елемент з H_low.
            Інакше медіана - найменший елемент з H_high.
            
    Наведений алгоритм використовує процедури extract_max незростаючої піраміди
    H_low та extract_min неспадної піраміди H_high, які виконуються за час 
    O(logN), де N - розмір піраміди. Тому на кожній ітерації #i для поточного
    масиву A' = [x_1, ..., x_i] час роботи наведеної процедури становитиме 
    O(log(i)).
    
ЗАВДАННЯ:
    1) Для розв'язання наведеної в описі роботи задачі визначення медіан 
    необхідно реалізувати функціонал двох пірамід. Обидві піраміди реалізуються
    у вигляді класів: MaxHeap - незростаюча піраміда (для реалізації H_low) та 
    MinHeap - неспадна піраміда (для реалізації H_high). Сам розглянутий вище 
    алгоритм реалізований у процедурі get_median.
    
    У кожному класі потрібно реалізувати базові операції обслуговування пірамід.
    Для MaxHeap: процедури max, extract_max, increase_value, insert, max_heapify.
    Для MinHeap: процедури min, extract_min, decrease_value, insert, min_heapify.
    Деталі реалізації - див. код відповідних методів в описі класів.
    
    
ДОКУМЕНТАЦІЯ:
    Python v2.7.3 documentation:
        - http://docs.python.org/2/
        - http://oim.asu.kpi.ua/python/docs (дзеркало, доступне з кафедральних комп'ютерів)
    Книга "Dive Into Python":
        - http://www.diveintopython.net/
        - http://oim.asu.kpi.ua/python/diveintopython/html/ (дзеркало, доступне з кафедральних комп'ютерів)
    Лекційні матеріали "Тема 7. Піраміди":
        - http://oim.asu.kpi.ua/files/TA/07_Heaps.pdf
"""

import random

class MaxHeap:
    """
    Клас MaxHeap реалізує незростаючу піраміду (heap)
    Властивості:
        heap - масив, який містить елемент піраміди; в кожний момент часу для
                даного масиву повинна зберігатись властивість незростаючої піраміди
                
    Методи:
        max - повертає найбільший елемент піраміди
        extract_max - видаляє та повертає найбільший елемент піраміди
        increase_value - збільшує значення елементу за індексом
        insert - вставляє елемент у піраміду
        max_heapify - відновлення властивості незростаючої піраміди
        display - вивід вмісту піраміди
        size - повертає поточний розмір піраміди
        
    ЗАВДАННЯ:
        Необхідно наповнити наведені нижче методи класу MaxHeap:
            max, extract_max, increase_value, insert, max_heapify
    """
    def __init__(self):
        """
        Конструктор класу. Визначає та ініціалізує властивості.
        """
        self.heap = [None]
        
    def display(self):
        """
        Процедура виводу вмісту піраміди.
        """
        print 'Max-Heap: [', ', '.join('{0}'.format(x) for x in self.heap), ']'
        
    def size(self):
        """
        Процедура повертає поточний розмір піраміди
        """
        return len(self.heap)
    
    def max(self):
        """
        Процедура повернення максимального значення з незростаючої піраміди.
        Повертає:
            значення найбільшого елементу в піраміді
        """
        
        if self.size() <= 1:
            return
        return self.heap[1]
        
    def extract_max(self):
        """
        Процедура видаляє та повертає максимальне значення з незростаючої піраміди. 
        Повертає:
            значення найбільшого елементу в піраміді
            
        УВАГА:
            - Необхідно перевірити, чи піраміда не порожня.
            - Після видалення найбільшого елементу необхідно відновити властивість
            незростаючої піраміди за допомогою методу max_heapify.
        """
        
        if self.size() <= 1:
            return
        tmp = self.heap[1]
        
        self.heap[1] = self.heap.pop()
        self.max_heapify(1)
        return tmp
        
    def increase_value(self, i, value):
        """
        Процедура збільшує значення елементу піраміди за заданим індексом.
        Параметри:
            i - індекс елементу з масиву self.heap
            value - нове значення елементу
            
        УВАГА:
            - Необхідно перевірити, що введений індекс є коректним.
            - Необхідно перевірити, що поточне значення елементу не більше 
            нового значення value (інакше нічого не робити)
            - Після приписування нового значення необхідно відновити властивість
            незростаючої піраміди.
        """
        
        if i < 1 or i >= self.size():
            return
        if value < self.heap[i]:
            return
        self.heap[i] = value
        self.max_heapify(i)
        return
    
    def insert(self, value):
        """
        Процедура вставки нового елементу в піраміду.
        Параметри:
            value - значення нового елементу
            
        УВАГА:
            - Можна використовувати метод self.increase_value для реалізації 
            даного методу
        """
        
        self.heap.append(value)
        self.buble_up(self.size() - 1)
        return
        
    def max_heapify(self, i):
        """
        Процедура відновлення властивості незростаючої піраміди для заданого індексу.
        Параметри:
            i - індекс елементу з масиву self.heap, для якого буде виконуватись 
            перевірка та відновлення властивості незростаючої піраміди
            
        УВАГА:
            - Необхідно перевірити, що заданий індекс лежить у межах розміру піраміди
            - Для визначення індексу лівого нащадка елементу, використовуйте формулу
            2*i
            - Для визначення індексу правого нащадка елементу, використовуйте формулу
            2*i + 1
        """
        
        if i < 1 or i >= self.size():
            return
        
        x = 2 * i if 2 * i < self.size() else -1
        y = 2 * i + 1 if 2 * i + 1 < self.size() else -1
                                              
        if x == -1:
            return
        
        z = x
        if y != -1 and self.heap[x] < self.heap[y]:
            z = y
        
        self.heap[i], self.heap[z] = self.heap[z], self.heap[i]
        self.max_heapify(z)
        return
    
    def buble_up(self, i):
        if i == 1:
            return
        parent = i / 2
        if self.heap[parent] < self.heap[i]:
            self.heap[parent], self.heap[i] = self.heap[i], self.heap[parent]
            self.buble_up(parent)
        return
            
class MinHeap:
    """
    Клас MinHeap реалізує неспадну піраміду (heap)
    Властивості:
        heap - масив, який містить елемент піраміди; в кожний момент часу для
                даного масиву повинна зберігатись властивість неспадної піраміди
                
    Методи:
        min - повертає найменший елемент піраміди
        extract_min - видаляє та повертає найменший елемент піраміди
        decrease_value - збільшує значення елементу за індексом
        insert - вставляє елемент у піраміду
        min_heapify - відновлення властивості неспадної піраміди
        display - вивід вмісту піраміди
        size - повертає поточний розмір піраміди
        
    ЗАВДАННЯ:
        Необхідно наповнити наведені нижче методи класу MaxHeap:
            min, extract_min, decrease_value, insert, min_heapify
    """
    def __init__(self):
        """
        Конструктор класу. Визначає та ініціалізує властивості.
        """
        self.heap = [None]
        
    def display(self):
        """
        Процедура виводу вмісту піраміди.
        """
        print 'Min-Heap: [', ', '.join('{0}'.format(x) for x in self.heap), ']'
        
    def size(self):
        """
        Процедура повертає поточний розмір піраміди
        """
        return len(self.heap)
    
    def min(self):
        """
        Процедура повернення мінімального значення з неспадної піраміди.
        Повертає:
            значення найменшого елементу в піраміді
        """
        
        if self.size == 1:
            return
        
        return self.heap[1]
        
    def extract_min(self):
        """
        Процедура видаляє та повертає мінімальне значення з неспадної піраміди. 
        Повертає:
            значення найменшого елементу в піраміді
            
        УВАГА:
            - Необхідно перевірити, чи піраміда не порожня.
            - Після видалення найменшого елементу необхідно відновити властивість
            неспадної піраміди за допомогою методу min_heapify.
        """
        
        if self.size == 1:
            return 
        tmp = self.heap[1]
        
        self.heap[1] = self.heap.pop()
        self.min_heapify(1)
        return tmp
        
    def decrease_value(self, i, value):
        """
        Процедура зменшує значення елементу піраміди за заданим індексом.
        Параметри:
            i - індекс елементу з масиву self.heap
            value - нове значення елементу
            
        УВАГА:
            - Необхідно перевірити, що введений індекс є коректним.
            - Необхідно перевірити, що поточне значення елементу не менше 
            нового значення value (інакше нічого не робити)
            - Після приписування нового значення необхідно відновити властивість
            неспадної піраміди.
        """
        
        if i < 1 or i >= self.size():
            return 
        if value > self.heap[i]:
            return
        self.heap[i] = value
        self.min_heapify(i)
        return
   
    def insert(self, value):
        """
        Процедура вставки нового елементу в піраміду.
        Параметри:
            value - значення нового елементу
            
        УВАГА:
            - Можна використовувати метод self.decrease_value для реалізації 
            даного методу
        """
        
        self.heap.append(value)
        self.buble_up(self.size() - 1)
        return
        
    def min_heapify(self, i):
        """
        Процедура відновлення властивості неспадної піраміди для заданого індексу.
        Параметри:
            i - індекс елементу з масиву self.heap, для якого буде виконуватись 
            перевірка та відновлення властивості неспадної піраміди
            
        УВАГА:
            - Необхідно перевірити, що заданий індекс лежить у межах розміру піраміди
            - Для визначення індексу лівого нащадка елементу, використовуйте формулу
            2*i
            - Для визначення індексу правого нащадка елементу, використовуйте формулу
            2*i + 1
        """
        
        if i < 1 or i >= self.size():
            return
        
        x = (2 * i) if (2 * i) < self.size() else -1
        y = (2 * i + 1) if (2 * i + 1) < self.size() else -1
                                              
        if x == -1:
            return
        
        z = x
        if y != -1 and self.heap[x] > self.heap[y]:
            z = y
        
        self.heap[i], self.heap[z] = self.heap[z], self.heap[i]
        #print z, x, y
        self.min_heapify(z)
        return
    
    def buble_up(self, i):
        if i == 0:
            return
        parent = i / 2
        if self.heap[parent] > self.heap[i]:
            self.heap[parent], self.heap[i] = self.heap[i], self.heap[parent]
            self.buble_up(parent)
        return
            
def generate_data(n, gen_type="random"):
    """
    Функція генерації масивів.
    Параметри:
        n (int) - кількість елементів масиву
        gen_type (string) - тип згенерованих даних:
            "best" - відсортований масив (мінімальний час для сортування)
            "worst" - найгірший варіант для сортування
            "random" - послідовність елементів генерується випадкова 
                        (значення за замовчуванням)
                        
    Повертає:
        Масив (list) довжиною n з елементами від 1 до n
    """
    if gen_type=="best":
        a = [i+1 for i in range(n)]
        return a
    elif gen_type=="worst":
        a = [i+1 for i in reversed(range(n))]
        return a
    else:
        a = [i+1 for i in range(n)]
        random.shuffle(a)
        return a
        
# створити дві піраміди:
#   H_low - незростаюча піраміда для збереження меншої половини масиву
#   H_high - неспадна піраміда для збереження більшої половини масиву
H_low = MaxHeap()
H_high = MinHeap()

def get_median(value):
    """
    Процедура визначення медіани для чергового значення value вхідного масиву
    Параметри:
        value - значення з вхідного масиву
    Повертає:
        Якщо медіана єдина (кількість поточних елементів непарна), то повертає 
        значення цієї медіани 
        Якщо медіани дві (кількість поточних елементів парна), то повертає
        пару медіан у вигляді (median1, median2)
    """
    global H_low
    global H_high
    
    # вставити новий елемент у піраміду
    # для цього потрібно визначити в яку піраміду вставляти елемент
    # якщо нове значення менше максимального з першої половини масиву, то
    # вставити у піраміду H_low, інакше - у H_high
    if value <= H_low.max():
        H_low.insert(value)
    else:
        H_high.insert(value)
        
    # перевірити умову виконання інваріанту
    # якщо розмір однієї піраміди став більшим на 2 за розмір іншої, то 
    # взяти найбільний (з H_low) або найменший (з H_high) елемент і вставити
    # в іншу піраміду
    if H_low.size() >= H_high.size() + 2:
        m = H_low.extract_max()
        H_high.insert(m)
    elif H_high.size() >= H_low.size() + 2:
        m = H_high.extract_min()
        H_low.insert(m)
        
    # вирахувати поточну медіану
    # якщо загальна кількість елементів парна, то повернути пару елементів:
    # один з H_low, один з H_high
    if (H_low.size() + H_high.size())%2 == 0:
        return (H_low.max(), H_high.min())
    # якщо кількість елементів непарна, то обрати піраміду, в якій елементів
    # більше, і повернути найбільший (найменший) елемент з цієї піраміди
    elif H_low.size() > H_high.size():
        return H_low.max()
    else:
        return H_high.min()

def test(seq):
    """
    Процедура визначення послідовних медіан для вхідного масиву. 
    Під час роботи процедура послідовно бере кожний поточний елемент з вхідного
    масиву та для усіх обраних елементів на даний момент повертає медіани.
    Параметри:
        seq - вхідний масив цілих чисел
    
    """
    print "Input array:", seq
    for i in range(len(seq)):
        a = seq[:i+1]
        a.sort()
        print "Current array:", a, "Median:", get_median(seq[i])
        
seq = generate_data(10)
test(seq)