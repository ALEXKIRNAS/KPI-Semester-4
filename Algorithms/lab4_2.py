# -*- coding: utf-8 -*-
"""
Created on Tue Mar 26 00:04:41 2013

@author: Admin
"""

"""
Лабораторна робота №4 з курсу "Теорія алгоритмів"
Спеціальність: Інформаційні управляючі системи та технології

ТЕМА: 
    Обрахунок опуклої оболонки множини точок на декартовій площині.
    
ОПИС РОБОТИ:
    В галузі обчислювальної геометрії досить часто виникає задача визначення
    опуклої оболонки (багатокутника), яка містить деяку множину точок на 
    площині.
    
    Проблема полягає у наступному. Заданий набір N різних точок на площині.
    Потрібно визначити таку підмножину точок H, які утворюють опуклий 
    багатокутник, що всі інші точки площини будуть знаходитись в межах знайденого
    багатокутника.
    
    В основі багатьох алгоритмів, які розв'язують поставлену задачу, лежить 
    наступне спостереження. Пара точок (P, Q) лежать на опуклій оболонці
    (тобто утворюють ребро опуклого багатокутника), якщо всі інші точки
    утворюють поворот проти годинникової стрілки, або лівий поворот, з вектором 
    PQ.
    Що це за повороти та як дізнатись, який поворот утворюють три точки?
    Нехай задані три точки A, B, C. Говорять, що ці точки утворюють поворот
    проти годинникової стрілки (лівий поворот), якщо проходячи відрізок AB для
    досягнення точки C нам потрібно повернути ліворуч; якщо потрібно повернути
    праворуч, то це буде правий поворот, або поворот за годинниковою стрілкою.
    Існує простий метод, який дозволяє визначити тип повороту. Розглянемо матрицю
                    | A_x A_y  1 |
                    | B_x B_y  1 |
                    | C_x C_y  1 |
    Детермінант цієї матриці дорівнює подвійній площі трикутника ABC. Причому 
    якщо значення детермінанту більше нуля, то точки A, B, C утворюють лівий 
    поворот; якщо менше нуля - правий; і якщо дорівнює нулю, то точки лежать
    на одній прямій (тобто колінеарні).
    
ЗАВДАННЯ:
    1) Реалізувати алгоритм, який розв'язує поставлену задачу повним перебором.
    Для цього написати функцію get_convex_hull_brute_force (див. коментарі до функції).
    
    2) (На додаткові 2 бали) Реалізувати більш швидкий алгоритм, який реалізує
    алгоритм Грехема знаходження опуклої оболонки. Для цього написати функцію 
    get_convex_hull_graham (див. коментарі до функції)
    
ДОКУМЕНТАЦІЯ:
    Python v2.7.3 documentation:
        - http://docs.python.org/2/
        - http://oim.asu.kpi.ua/python/docs (дзеркало, доступне з кафедральних комп'ютерів)
    Книга "Dive Into Python":
        - http://www.diveintopython.net/
        - http://oim.asu.kpi.ua/python/diveintopython/html/ (дзеркало, доступне з кафедральних комп'ютерів)

"""

import matplotlib.pyplot as plt
import numpy as np

def get_tan(x0, y0, x1, y1):
    """
    Функція обрахунку тангенсу кута нахилу прямої (x0, y0)-(x1, y1) до вісі ОХ.
    Параметри:
        x0 - координата х першої точки
        y0 - координата y першої точки
        x1 - координата х другої точки
        y1 - координата y другої точки
    Повертає:
        Значення тангенсу кута нахилу прямої до вісі ОХ.
    """
    if x1==x0:
        return float('inf')
    else:
        return float(y1 - y0) / float(x1 - x0)
        
def get_cotan(x0, y0, x1, y1):
    """
    Функція обрахунку котангенсу кута нахилу прямої (x0, y0)-(x1, y1) до вісі ОХ.
    Параметри:
        x0 - координата х першої точки
        y0 - координата y першої точки
        x1 - координата х другої точки
        y1 - координата y другої точки
    Повертає:
        Значення котангенсу кута нахилу прямої до вісі ОХ.
    """
    if y1==y0:
        return float('inf')
    else:
        return float(x1 - x0) / float(y1 - y0)
        
def load_data(filename):
    """
    Функція завантаження вхідного масиву точок з файлу. 
    Вхідний файл повинен мати наступний формат:
        перший рядок містить ціле число N - кількість точок
        наступні N рядків містять пари чисел - координати (x, y) точок
    Параметри:
        filename - ім'я файлу
    Повертає:
        Масив точок у вигляді пар координат (x, y)
    """
    data = []
    with open(filename, 'r') as f:
        n = int(f.readline())
        for line in f:
            x, y = tuple([int(x) for x in line.split()])
            data.append((x,y))
    return data
    
def plot_data(data, hull1=[], hull2=[]):
    """
    Функція побудови зображення точок та знайдених багатокутників оболонок. 
    Функція будує декартову площину; відображає на ній точки з масиву data; 
    малює сегменти випуклих багатокутників hull1 та hull2. Сегменти першого та 
    другого масивів відображаються різними кольорами для того щоб мати можливість 
    перевірити, чи однакові оболонки містять обидва масиви.
    Параметри:
        data - масив точок; елементами масиву є пари (x,y) координат 
        hull1 - перша оболонка; є масивом, кожний елемент якого - це четвірка
                (x1, y1, x2, y2), яка визначає один з сегментів (ребер) оболонки.
                x1, y1 - координати першої точки сегменту
                x2, y2 - координати другої точки сегменту
        hull2 - друга оболонка; визначається так само як і перша
    """
    fig = plt.figure(1)
    ax = fig.add_subplot(111)
    ax.axis('equal')
    for p in data:
        ax.plot(p[0], p[1], 'o', color='b')
    ax.set_xlim( (min([p[0] for p in data])*0.9, max([p[0] for p in data])*1.1) )
    ax.set_ylim( (min([p[1] for p in data])*0.9, max([p[1] for p in data])*1.1) )
    for segm in hull1:
        ax.plot([segm[0], segm[2]], [segm[1], segm[3]], 'r-')
    for segm in hull2:
        ax.plot([segm[0], segm[2]], [segm[1], segm[3]], 'b--')
    plt.show()
    
def ccw(a, b, c):
    """
    Функція визначення типу повороту при обході трьох точок. 
    Три точки (a, b, c) йдуть проти годинникової стрілки якщо ccw > 0, за 
    стрілкою якщо ccw < 0, і колінеарні якщо ccw = 0. 
    Параметри:
        a - перша точка у вигляді пари координат (x, y)
        b - друга точка у вигляді пари координат (x, y)
        c - третя точка у вигляді пари координат (x, y)
    Повертає:
        Значення площі трикутника, який утворюється заданими трьома точками.
        Якщо це значення більше нуля, то точки утворюють лівий поворот (проти 
        годинникової стрілки); якщо менше нуля, то точки утворюють правий 
        поворот (за годинниковою стрілкою); якщо дорівнює нулю, то точки лежать
        на одній прямій (колінеарні).
    """
    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])
    
def get_convex_hull_brute_force(data):
    """
    Функція знаходження опуклої оболонки точок, що містяться у вхідному масиві. 
    
    Параметри:
        data - масив точок, який містить пари координат (x, y) всіх точок
    Повертає:
        hull - масив сегментів опуклої оболонки (багатокутника).
                Кожний сегмент задається парами координат своїх кінців
                Наприклад: [[x0,y0,x1,y1],[x1,y1,x2,y2],...]
                (Масив не обов'язково повинен зберігати порядок сегментів у 
                оболонці; головне 
                            
    ЗАВДАННЯ:
        Вашим завданням є реалізувати brute force алгоритм (метод "в лоб"), 
        який знаходить опуклий багатокутник (оболонку), утворений деякими із
        заданих точок та такий, що всі інші точки знаходяться в середині нього.
        
        Алгоритм заснований на повному переборі: 
            - для всіх пар точок p та q в data:
                - обрахувати ccw(p, q, x) для всіх інших точок x
                - якщо всі ці значення позитивні, то точки p та q утворюють 
                сегмент опуклого багатокутника
              
        Складність даного алгоритму дорівнює O(N^3), де N - кількість точок
        в масиві data.
    """
    hull = []
    n = len(data)
    for i in xrange(n):
        for j in xrange(n):
            flag = True
            for k in xrange(n):
                if (i == j or i == k or j == k):
                    continue
                if (ccw(data[i], data[j], data[k]) < 0):
                    flag = False
                    break
            if flag == True:
                arr = [data[i][0], data[i][1], data[j][0], data[j][1]]
                hull.append(arr)
    # ВАШ КОД
    
    return hull
    
def get_convex_hull_graham(data):
    """
    Функція знаходження опуклої оболонки точок, що містяться у вхідному масиві,
    за допомогою алгоритму Грехема.
    
    Параметри:
        data - масив точок, який містить пари координат (x, y) всіх точок
    Повертає:
        hull - масив сегментів опуклої оболонки (багатокутника).
                Кожний сегмент задається парами координат своїх кінців
                Наприклад: [[x0,y0,x1,y1],[x1,y1,x2,y2],...]
                (Масив не обов'язково повинен зберігати порядок сегментів у 
                оболонці; головне 
                            
    ЗАВДАННЯ:
        Вашим завданням є реалізувати алгоритм  Грехема, 
        який знаходить опуклий багатокутник (оболонку), утворений деякими із
        заданих точок та такий, що всі інші точки знаходяться в середині нього.
        
        Алгоритм Грехема працює наступним чином:
            - Перший крок в алгоритмі - знайти точку з найменшою у-координатою. 
            Якщо таких декілька, то обираємо серед них точку з найменшою 
            х-координатою. Назвемо її P.
            - Всі інші точки мають бути відсортовані в порядку зростання кута, 
            який вони разом з P утворюють з віссю х. При цьому не обов'язково 
            визначати кут, що ці точки утворюють з віссю х; замість цього 
            достатньо обчислити котангенс цього кута: це монотонно спадна 
            функція на проміжку, що важливий для цього кроку (від 0 до 180 
            градусів)
            - Додати до стеку S точку P та першу точку з відсортованого масиву 
            (тобто таку, яка утворює найменший кут з P)
            - Для всіх інших точок p_i (i від 3 до N):
                - допоки кут, утворений двома верхніми точками стеку та 
                поточною точкою утворює НЕ лівий поворот
                ( ccw(NextToTop(S), Top(S), p_i) <= 0 ):
                    - видалити точку з голови стеку S
                - додати нову точку p_i до стеку S
            - Стек S містить точки, які утворюють опуклу оболонку всіх точок з 
            data
        
        Складність даного алгоритму дорівнює O(N*logN), де N - кількість точок
        в масиві data.
        Детальніше про алгоритм: 
            - http://ru.wikipedia.org/wiki/Алгоритм_Грэхема
            - http://en.wikipedia.org/wiki/Graham_scan
    """
    hull = []
    
    # ВАШ КОД
    n = len(data)
    data.sort()
    p1 = data[0]
    p2 = data[n-1]
    up = [p1]
    down = [p1]
    
    for i in range(1, n):
        if (i == n - 1 or ccw (p1, data[i], p2) >= 0):
            while (len(up) >= 2 and ccw (up[len(up) - 1], up[len(up) - 2], data[i]) >= 0):
                up.pop()
            up.append(data[i])
            
        if (i == n - 1 or ccw (p1, data[i], p2) <= 0):
             while (len(down) >= 2 and ccw (down[len(down) - 1], down[len(down) - 2], data[i]) <= 0):
                down.pop()
             down.append(data[i])

    for x in xrange(1, len(up)):
        arr =[up[x - 1][0], up[x - 1][1], up[x][0], up[x][1]]
        hull.append(arr)
    for x in xrange(1, len(down)):
        arr =[down[x - 1][0], down[x - 1][1], down[x][0], down[x][1]]
        hull.append(arr)
    #hull.append([p1[0], p1[1], p2[0], p2[1]])
    return hull
    
data = load_data('points_20.txt')
hull1 = get_convex_hull_brute_force(data)
hull2 = get_convex_hull_graham(data)
plot_data(data, hull1, hull2)